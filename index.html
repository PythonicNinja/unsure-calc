<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Unsure Calculator</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <link href="https://fonts.googleapis.com/css2?family=DM+Serif+Display:ital,wght@0,400;1,400&family=Manrope:wght@400;600;700&display=swap" rel="stylesheet">
        <style>
            body {
                font-family: 'Manrope', 'Inter', 'system-ui', 'Segoe UI', Arial, sans-serif;
                background: linear-gradient(135deg, #f7e7ce 0%, #fff6f0 100%);
                letter-spacing: 0.01em;
            }
            .ft-card {
                background: linear-gradient(135deg, #fff6f0 60%, #f7e7ce 100%);
                border: 2px solid #bfa36f;
                border-radius: 18px;
                box-shadow: 0 6px 32px 0 rgba(80, 60, 30, 0.10), 0 1.5px 6px 0 rgba(191, 163, 111, 0.12);
                padding: 3.2rem 2.3rem 2.5rem 2.3rem;
                max-width: 540px;
                margin: 0 auto;
            }
            h1 {
                font-family: 'DM Serif Display', serif;
                font-size: 2.7rem;
                font-weight: 400;
                color: #bfa36f;
                margin-bottom: 2.3rem;
                text-align: center;
                letter-spacing: 0.01em;
                text-shadow: 0 2px 8px #fff6f0, 0 1px 0 #bfa36f;
            }
            label {
                font-family: 'Manrope', 'Inter', 'system-ui', Arial, sans-serif;
                font-size: 1.08rem;
                color: #bfa36f;
                font-weight: 700;
                margin-bottom: 0.7rem;
                display: block;
                letter-spacing: 0.01em;
            }
            input[type="text"] {
                width: 100%;
                padding: 1.15rem 1.5rem;
                border: 2px solid #bfa36f;
                border-radius: 10px;
                background: #fff6f0;
                font-size: 1.18rem;
                color: #3a2c13;
                transition: border 0.22s, box-shadow 0.22s;
                font-family: 'Manrope', 'Inter', 'system-ui', Arial, sans-serif;
                box-sizing: border-box;
                box-shadow: 0 1.5px 6px 0 rgba(191, 163, 111, 0.08);
            }
            input[type="text"]:focus {
                outline: none;
                border-color: #e0b973;
                box-shadow: 0 0 0 2px #f2e6d9, 0 1.5px 6px 0 #e0b97333;
            }
            button {
                width: 100%;
                padding: 1.15rem 0;
                background: linear-gradient(90deg, #bfa36f 70%, #e0b973 100%);
                color: #fff6f0;
                font-family: 'Manrope', 'Inter', 'system-ui', Arial, sans-serif;
                font-weight: 700;
                font-size: 1.22rem;
                border: none;
                border-radius: 10px;
                cursor: pointer;
                transition: background 0.18s, box-shadow 0.18s, color 0.18s;
                box-shadow: 0 2px 16px 0 #bfa36f22, 0 1.5px 6px 0 #bfa36f33;
                letter-spacing: 0.01em;
                margin-bottom: 0.3rem;
            }
            button:hover, button:focus {
                background: linear-gradient(90deg, #e0b973 0%, #bfa36f 100%);
                color: #3a2c13;
                box-shadow: 0 4px 24px 0 #bfa36f33, 0 2px 8px 0 #e0b97344;
            }
            #result-container {
                font-family: 'JetBrains Mono', 'Menlo', 'Monaco', 'Consolas', monospace;
                background: linear-gradient(135deg, #fff6f0 80%, #f7e7ce 100%);
                border: 2px solid #bfa36f;
                border-radius: 10px;
                padding: 1.5rem 1.2rem 1.2rem 1.2rem;
                margin-top: 2.1rem;
                min-height: 4em;
                overflow-x: auto;
                color: #3a2c13;
                box-shadow: 0 2px 16px 0 #bfa36f1a, 0 1.5px 6px 0 #bfa36f22;
            }
            .histogram-line {
                display: flex;
                align-items: baseline;
            }
            .histogram-label {
                width: 8ch;
                text-align: right;
                padding-right: 0.5em;
                flex-shrink: 0;
                color: #6D7175;
            }
            .histogram-separator {
                padding-right: 0.5em;
                flex-shrink: 0;
            }
            .histogram-bar {
                flex-grow: 1;
                white-space: nowrap;
                overflow: hidden;
                color: #bfa36f;
                border-radius: 3px;
            }
            #result-summary div {
                font-size: 1.11rem;
                color: #3a2c13;
                font-family: 'Manrope', 'Inter', 'system-ui', Arial, sans-serif;
            }
            .text-xs {
                color: #bfa36f;
                text-align: center;
                font-size: 0.97rem;
                font-family: 'Manrope', 'Inter', 'system-ui', Arial, sans-serif;
            }
        </style>
    </head>
    <body
        class="bg-gray-100 text-gray-800 min-h-screen flex items-center justify-center p-4"
    >
        <div class="bg-white p-4 rounded-lg shadow-md w-full max-w-4xl">
            <h1
                class="text-3xl font-bold mb-6 text-center tracking-wide text-gray-700 cursor-pointer"
                onclick="reset()"
            >
                Unsure Calculator
            </h1>

            <div class="mb-6 flex items-center gap-3">
                <input
                    type="text"
                    id="expression"
                    placeholder="e.g., 100~200 * (5 ~ 7 + 1)"
                    class="flex-grow border-2 border-[#bfa36f] rounded-l-xl bg-[#fff6f0] text-lg leading-relaxed tracking-wider font-medium focus:outline-none focus:border-[#e0b973] focus:ring-2 focus:ring-[#e0b973] transition duration-150 ease-in-out shadow-sm"
                />
                <button
                    id="calculateBtn"
                    class="px-4 py-4 bg-[#e0b973] hover:bg-[#bfa36f] text-[#3a2c13] font-bold text-xl rounded-r-xl focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[#e0b973] transition duration-150 ease-in-out shadow-md"
                    style="max-width: 50px"
                >
                    =
                </button>
            </div>

            <div class="mt-6">
                <div
                    id="result-container"
                    class="bg-gray-50 p-4 rounded-md text-sm leading-relaxed tracking-wider border border-gray-200 min-h-[4em] overflow-x-auto"
                >
                    <div id="result-summary"></div>
                    <div id="result-histogram"></div>
                </div>
            </div>
            <p class="text-xs text-gray-500 mt-4 text-center">
                Use '~' for ranges. 
                <br>
                EURPLN range: 4.1~4.3
            </p>
        </div>

        <script>
            const expressionInput = document.getElementById("expression");
            const calculateBtn = document.getElementById("calculateBtn");
            const resultSummaryDisplay =
                document.getElementById("result-summary");
            const resultHistogramDisplay =
                document.getElementById("result-histogram");
            const resultContainer = document.getElementById("result-container");

            const NUM_SAMPLES = 10000;
            const HISTOGRAM_BINS = 30;
            const HISTOGRAM_MAX_WIDTH = 30;
            const BAR_CHAR = "█";

            const params = new URLSearchParams(window.location.search);
            const expr = decodeURIComponent(params.get('expr'));
            if (expr !== "null") {
                expressionInput.value = expr;
            }

            function reset() {
                expressionInput.value = "";
                calculate();
                expressionInput.focus();
            }

            // --- Gaussian Random Number Generator (Box-Muller Transform) ---
            let spareRandom = null;
            function gaussianRandom(mean, stdDev) {
                let u, v, s;
                if (spareRandom !== null) {
                    const temp = spareRandom;
                    spareRandom = null;
                    return mean + stdDev * temp;
                }
                do {
                    u = Math.random() * 2 - 1;
                    v = Math.random() * 2 - 1;
                    s = u * u + v * v;
                } while (s >= 1 || s === 0);
                const mul = Math.sqrt((-2.0 * Math.log(s)) / s);
                spareRandom = v * mul;
                return mean + stdDev * (u * mul);
            }

            function generateSamples(mean, stdDev) {
                if (stdDev === 0) {
                    // Optimization: if range is zero, all samples are the mean
                    return Array(NUM_SAMPLES).fill(mean);
                }
                const samples = [];
                for (let i = 0; i < NUM_SAMPLES; i++) {
                    samples.push(gaussianRandom(mean, stdDev));
                }
                return samples;
            }

            // --- Tokenizer (Unchanged) ---
            function tokenize(s) {
                const tokens = [];
                const NUMBER_REGEX = /^-?[0-9]+(\.[0-9]+)?/;
                const OPERATOR_REGEX = /^[+\-*^/~()]/;
                const WHITESPACE_REGEX = /^\s+/;
                let remaining = s.trim();
                const originalString = s;
                while (remaining.length > 0) {
                    let match;
                    match = remaining.match(WHITESPACE_REGEX);
                    if (match) {
                        remaining = remaining.substring(match[0].length);
                        continue;
                    }
                    match = remaining.match(NUMBER_REGEX);
                    if (match) {
                        tokens.push(parseFloat(match[0]));
                        remaining = remaining.substring(match[0].length);
                        continue;
                    }
                    match = remaining.match(OPERATOR_REGEX);
                    if (match) {
                        tokens.push(match[0]);
                        remaining = remaining.substring(match[0].length);
                        continue;
                    }
                    throw new Error(
                        `Syntax Error: Cannot parse near '${remaining.substring(0, 10)}...' in expression '${originalString}'`,
                    );
                }
                return tokens;
            }

            function shuntingYard(tokens) {
                // Track previous token to distinguish unary/binary minus
                let prevToken = null;
                const outputQueue = [];
                const operatorStack = [];
                const precedence = { "+": 1, "-": 1, "*": 2, "/": 2, "^": 3, "~": 4 };
                const associativity = {
                    "+": "L",
                    "-": "L",
                    "*": "L",
                    "/": "L",
                    "^": "L",
                    "~": "R",
                };
                for (const token of tokens) {
                // Detect unary minus: at start, after (, or after another operator
                if (token === '-') {
                    if (
                        prevToken == null ||
                        prevToken === '(' ||
                        (typeof prevToken !== 'number' && prevToken !== ')')
                    ) {
                        // Treat as unary minus
                        operatorStack.push('NEG');
                        prevToken = token;
                        continue;
                    }
                }
                    if (typeof token === "number") {
                        outputQueue.push(token);
                    prevToken = token;
                    } else if (token === "(") {
                        operatorStack.push(token);
                    prevToken = token;
                    } else if (token === ")") {
                        while (
                            operatorStack.length > 0 &&
                            operatorStack[operatorStack.length - 1] !== "("
                        ) {
                            outputQueue.push(operatorStack.pop());
                        }
                        if (operatorStack.length === 0)
                            throw new Error(
                                "Mismatched parentheses: Found ')' without matching '('",
                            );
                        operatorStack.pop();
                    } else if (precedence[token]) {
                        const op1 = token;
                        while (
                            operatorStack.length > 0 &&
                            operatorStack[operatorStack.length - 1] !== "(" &&
                            (precedence[
                                operatorStack[operatorStack.length - 1]
                            ] > precedence[op1] ||
                                (precedence[
                                    operatorStack[operatorStack.length - 1]
                                ] === precedence[op1] &&
                                    associativity[op1] === "L"))
                        ) {
                            outputQueue.push(operatorStack.pop());
                        }
                        operatorStack.push(op1);
                    prevToken = token;
                    } else {
                        throw new Error(`Unknown token: ${token}`);
                    }
                }
                while (operatorStack.length > 0) {
                    const op = operatorStack.pop();
                    if (op === "(")
                        throw new Error(
                            "Mismatched parentheses: Found '(' without matching ')'",
                        );
                    outputQueue.push(op);
                }
                return outputQueue; // 'NEG' will be in outputQueue as needed
            }

            function evalRpn(rpnQueue) {
                // Support unary minus (NEG)

                const stack = [];

                const createNumberValue = (num) => ({
                    mean: num,
                    min: num,
                    max: num,
                    samples: null,
                });

                const operateSamples = (samplesA, samplesB, operation) => {
                    if (!samplesA && !samplesB) return null; // Both numbers

                    const N = NUM_SAMPLES;
                    const resultSamples = Array(N);
                    const aIsArray = Array.isArray(samplesA);
                    const bIsArray = Array.isArray(samplesB);

                    for (let i = 0; i < N; i++) {
                        const a = aIsArray ? samplesA[i] : samplesA;
                        const b = bIsArray ? samplesB[i] : samplesB;

                        switch (operation) {
                            case "+":
                                resultSamples[i] = a + b;
                                break;
                            case "-":
                                resultSamples[i] = a - b;
                                break;
                            case "*":
                                resultSamples[i] = a * b;
                                break;
                            case "/":
                                resultSamples[i] = b === 0 ? NaN : a / b;
                                break;
                            case "^":
                                resultSamples[i] = Math.pow(a, b);
                                break;
                            default:
                                throw new Error(
                                    `Unknown sample operation: ${operation}`,
                                );
                        }
                    }
                    return resultSamples;
                };

                for (const token of rpnQueue) {
                    if (token === 'NEG') {
                        if (stack.length < 1)
                            throw new Error("Not enough operands for unary minus");
                        const a = stack.pop();
                        // Negate all fields
                        const nmin = Math.min(-a.max, -a.min);
                        const nmax = Math.max(-a.max, -a.min);
                        stack.push({
                            mean: -a.mean,
                            min: nmin,
                            max: nmax,
                            samples: a.samples ? a.samples.map(x => -x) : null,
                        });
                        continue;
                    }

                    if (typeof token === "number") {
                        stack.push(createNumberValue(token));
                    } else if (token === "~") {
                        if (stack.length < 2)
                            throw new Error("Not enough operands for '~'");
                        const uvB = stack.pop();
                        const uvA = stack.pop();

                        // '~' must operate on plain numbers
                        if (
                            uvA.samples !== null ||
                            uvB.samples !== null ||
                            typeof uvA.mean !== "number" ||
                            typeof uvB.mean !== "number"
                        ) {
                            throw new Error(
                                "Operands for '~' must be exact numbers (e.g., 100~200, not (5~10)~200)",
                            );
                        }
                        const a = uvA.mean;
                        const b = uvB.mean;

                        const mean = (a + b) / 2.0;
                        const stdDev = Math.abs(b - a) / 3.28970725; // Approx 5th-95th range match
                        const samples = generateSamples(mean, stdDev);

                        stack.push({
                            mean: mean,
                            min: Math.min(a, b),
                            max: Math.max(a, b),
                            samples: samples,
                        });
                    } else if ("+-*/^".includes(token)) {
                        if (stack.length < 2)
                            throw new Error(
                                `Not enough operands for '${token}'`,
                            );
                        const uvB = stack.pop();
                        const uvA = stack.pop();

                        let newMean, newMin, newMax;

                        // --- Calculate New Mean ---
                        // Approximation for * and / assuming independence (matches Monte Carlo implicit assumption)
                        switch (token) {
                            case "+":
                                newMean = uvA.mean + uvB.mean;
                                break;
                            case "-":
                                newMean = uvA.mean - uvB.mean;
                                break;
                            case "*":
                                newMean = uvA.mean * uvB.mean;
                                break;
                            case "/":
                                newMean =
                                    uvB.mean === 0 ? NaN : uvA.mean / uvB.mean;
                                break; // Handle division by zero mean
                            case "^":
                                newMean = Math.pow(uvA.mean, uvB.mean);
                                break;
                        }

                        // --- Calculate New Min/Max (Interval Arithmetic) ---
                        const aMin = uvA.min,
                            aMax = uvA.max;
                        const bMin = uvB.min,
                            bMax = uvB.max;

                        switch (token) {
                            case "+":
                                newMin = aMin + bMin;
                                newMax = aMax + bMax;
                                break;
                            case "-":
                                newMin = aMin - bMax;
                                newMax = aMax - bMin;
                                break;
                            case "*":
                                const prods = [
                                    aMin * bMin,
                                    aMin * bMax,
                                    aMax * bMin,
                                    aMax * bMax,
                                ];
                                newMin = Math.min(...prods);
                                newMax = Math.max(...prods);
                                break;
                            case "^":
                                const powers = [
                                    aMin ** bMin,
                                    aMin ** bMax,
                                    aMax ** bMin,
                                    aMax ** bMax,
                                ];
                                newMin = Math.min(...powers);
                                newMax = Math.max(...powers);
                                break;
                            case "/":
                                if (bMin <= 0 && bMax >= 0) {
                                    // Range includes zero
                                    if (bMin === 0 && bMax === 0) {
                                        // Division by exactly zero
                                        newMin = NaN;
                                        newMax = NaN;
                                        newMean = NaN; // Or throw error maybe?
                                    } else {
                                        // Range spans zero, result spans infinity (unless numerator is exactly 0)
                                        if (aMin === 0 && aMax === 0) {
                                            newMin = 0;
                                            newMax = 0;
                                        } else {
                                            newMin = -Infinity;
                                            newMax = Infinity;
                                        }
                                    }
                                } else {
                                    // Divisor range does not include zero
                                    const quots = [
                                        aMin / bMin,
                                        aMin / bMax,
                                        aMax / bMin,
                                        aMax / bMax,
                                    ];
                                    newMin = Math.min(...quots);
                                    newMax = Math.max(...quots);
                                }
                                break;
                        }

                        // --- Calculate New Samples ---
                        // Pass means if samples are null
                        const samplesA = uvA.samples ?? uvA.mean;
                        const samplesB = uvB.samples ?? uvB.mean;
                        const newSamples = operateSamples(
                            samplesA,
                            samplesB,
                            token,
                        );

                        stack.push({
                            mean: newMean,
                            min: newMin,
                            max: newMax,
                            samples: newSamples,
                        });
                    } else {
                        throw new Error(
                            `Internal Error: Unknown RPN token: ${token}`,
                        );
                    }
                }

                if (stack.length === 0) return null;
                if (stack.length > 1)
                    throw new Error("Invalid expression: Operands left over");
                return stack[0]; // The final UncertainValue object
            }

            // --- Quantile Calculation (Unchanged) ---
            function getQuantiles(samples) {
                if (!Array.isArray(samples) || samples.length === 0)
                    return { p05: NaN, p95: NaN };
                const validSamples = samples.filter(
                    (n) => !isNaN(n) && isFinite(n),
                );
                if (validSamples.length === 0) return { p05: NaN, p95: NaN };
                validSamples.sort((a, b) => a - b);
                const len = validSamples.length;
                const p05Index = Math.max(0, Math.floor(0.05 * len) - 1);
                const p95Index = Math.min(len - 1, Math.ceil(0.95 * len) - 1);
                return {
                    p05: validSamples[p05Index],
                    p95: validSamples[p95Index],
                };
            }

            // --- Format Number (Updated for better precision control) ---
            function formatNumber(num, padWidth = 0) {
                let str;
                const absNum = Math.abs(num);

                if (isNaN(num)) str = "NaN";
                else if (!isFinite(num))
                    str = num > 0 ? "Infinity" : "-Infinity";
                else if (absNum === 0) str = "0";
                else if (absNum < 1e-6 || absNum >= 1e9)
                    str = num.toExponential(4); // Exponential for very small/large
                else {
                    // Adaptive precision based on magnitude
                    let decimals;
                    if (absNum >= 1000) decimals = 1;
                    else if (absNum >= 100) decimals = 2;
                    else if (absNum >= 10) decimals = 3;
                    else if (absNum >= 1) decimals = 4;
                    else if (absNum >= 0.01) decimals = 5;
                    else decimals = 6; // More precision for smaller numbers

                    str = num.toFixed(decimals);
                    // Minimal cleanup
                    str = str.replace(/(\.[0-9]*?)0+$/, "$1"); // Remove trailing zeros
                    str = str.replace(/\.$/, ""); // Remove trailing decimal point
                }
                return padWidth > 0 ? str.padStart(padWidth) : str;
            }

            // --- Calculate Sample Mean (Unchanged) ---
            function calculateSampleMean(samples) {
                if (!Array.isArray(samples) || samples.length === 0) return NaN;
                const validSamples = samples.filter(
                    (n) => !isNaN(n) && isFinite(n),
                );
                if (validSamples.length === 0) return NaN;
                const sum = validSamples.reduce((acc, val) => acc + val, 0);
                return sum / validSamples.length;
            }

            // --- Generate Text Histogram (Unchanged) ---
            function generateTextHistogram(samples) {
                const numBins = HISTOGRAM_BINS;
                const maxBarWidth = HISTOGRAM_MAX_WIDTH;
                const output = [];
                if (!Array.isArray(samples) || samples.length === 0)
                    return ["Histogram data not available."];

                const validSamples = samples.filter(
                    (n) => !isNaN(n) && isFinite(n),
                );
                if (validSamples.length === 0)
                    return [
                        "Cannot generate histogram (no valid numeric samples).",
                    ];

                const minVal = Math.min(...validSamples);
                const maxVal = Math.max(...validSamples);
                const sampleMean = calculateSampleMean(validSamples);

                if (minVal === maxVal) {
                    const label = formatNumber(minVal, 7);
                    output.push(
                        `<div class="histogram-line"><span class="histogram-label">${label}</span><span class="histogram-separator">|</span><span class="histogram-bar">${BAR_CHAR.repeat(maxBarWidth)} (All samples)</span></div>`,
                    );
                    return output;
                }

                const binSize = (maxVal - minVal) / numBins;
                const binCounts = Array(numBins).fill(0);
                for (const sample of validSamples) {
                    let binIndex =
                        binSize === 0
                            ? 0
                            : Math.floor((sample - minVal) / binSize);
                    if (binIndex >= numBins) binIndex = numBins - 1;
                    if (binIndex < 0) binIndex = 0;
                    binCounts[binIndex]++;
                }

                const maxCount = Math.max(...binCounts);
                if (maxCount === 0)
                    return ["Cannot generate histogram (max count is zero)."];

                let peakBinIndex = binCounts.indexOf(maxCount);

                for (let i = numBins - 1; i >= 0; i--) {
                    const binStart = minVal + i * binSize;
                    const count = binCounts[i];
                    const barWidth =
                        maxCount === 0
                            ? 0
                            : Math.round((count / maxCount) * maxBarWidth);
                    const bar = BAR_CHAR.repeat(barWidth);
                    const label = formatNumber(binStart, 7);

                    let line = `<div class="histogram-line"><span class="histogram-label">${label}</span><span class="histogram-separator">|</span><span class="histogram-bar">${bar}`;
                    // Find which bin the sample mean falls into
                    let meanBinIndex =
                        binSize === 0
                            ? 0
                            : Math.floor((sampleMean - minVal) / binSize);
                    if (meanBinIndex >= numBins) meanBinIndex = numBins - 1;
                    if (meanBinIndex < 0) meanBinIndex = 0;
                    if (i === meanBinIndex) {
                        // Mark the bin containing the sample mean
                        line += ` (Sample Mean ≈${formatNumber(sampleMean)})`;
                    }
                    line += `</span></div>`;
                    output.push(line);
                }
                return output;
            }

            // --- Main Calculation Logic (Updated Output) ---
            function calculate() {
                const expression = expressionInput.value;
                resultSummaryDisplay.innerHTML = "<div>Calculating...</div>"; // Use innerHTML for multiple lines
                resultHistogramDisplay.innerHTML = "";
                resultContainer.classList.remove("border-red-600");
                resultSummaryDisplay.classList.remove("text-red-600");

                if (expression) {
                    // set query params
                    const params = new URLSearchParams();
                    params.set('expr', encodeURIComponent(expression));
                    window.history.pushState(null, '', `?${params.toString()}`);
                }

                setTimeout(() => {
                    try {
                        if (!expression.trim()) {
                            resultSummaryDisplay.innerHTML = "";
                            return;
                        }
                        const tokens = tokenize(expression);
                        const rpn = shuntingYard(tokens);
                        const result = evalRpn(rpn); // result is an UncertainValue object

                        if (!result) {
                            resultSummaryDisplay.innerHTML = "";
                            return;
                        }

                        let summaryHtml = "";
                        let hasError = false;

                        // Display Exact Results
                        if (
                            isNaN(result.mean) ||
                            isNaN(result.min) ||
                            isNaN(result.max)
                        ) {
                            summaryHtml += `<div><span class="text-red-600">Exact Result Contains NaN</span></div>`;
                            hasError = true;
                        } else {
                            summaryHtml += `<div>Exact Average: ${formatNumber(result.mean)}</div>`;
                            summaryHtml += `<div>Exact Range : ${formatNumber(result.min)} - ${formatNumber(result.max)}</div>`;
                        }

                        // Display Simulation Results (if applicable)
                        if (result.samples) {
                            const quantiles = getQuantiles(result.samples);
                            if (isNaN(quantiles.p05) || isNaN(quantiles.p95)) {
                                summaryHtml += `<div><span class="text-red-600">Simulated Result Contains NaN/Infinity</span></div>`;
                                hasError = true;
                            } else {
                                summaryHtml += `<div>Simulated Range (5%-95%): ${formatNumber(quantiles.p05)} ~ ${formatNumber(quantiles.p95)}</div>`;
                            }
                            // Generate and display histogram
                            const histogramLines = generateTextHistogram(
                                result.samples,
                            );
                            resultHistogramDisplay.innerHTML =
                                histogramLines.join("");
                        } else {
                            resultHistogramDisplay.innerHTML = ""; // Clear histogram if no samples
                            summaryHtml += `<div class="mt-2">(Result is an exact number, no simulation needed)</div>`;
                        }

                        resultSummaryDisplay.innerHTML = summaryHtml;
                        if (hasError) {
                            resultContainer.classList.add("border-red-600");
                        }
                    } catch (error) {
                        console.error("Calculation Error:", error);
                        resultSummaryDisplay.innerHTML = `<div><span class="text-red-600">Error: ${error.message}</span></div>`;
                        resultContainer.classList.add("border-red-600");
                        resultHistogramDisplay.innerHTML = ""; // Clear histogram on error
                    }
                }, 10);
            }

            // --- Event Listeners ---
            calculateBtn.addEventListener("click", calculate);
            expressionInput.addEventListener("keypress", (event) => {
                if (event.key === "Enter") calculate();
            });

            // --- Initial example calculation ---
            if (!expressionInput.value) {
                expressionInput.value = "7~10 * 17~23";
            }
            calculate();
        </script>
    </body>
</html>