<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Unsure Calculator</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <style>
            body {
                font-family: "Courier New", Courier, monospace;
                letter-spacing: 0.025em;
            }
            button:focus {
                outline: 2px solid transparent;
                outline-offset: 2px;
                box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);
            }
            input,
            #result-container {
                font-family: "Courier New", Courier, monospace;
                line-height: 1.6;
            }
            #result-container {
                text-wrap: nowrap;
                overflow-x: scroll;
            }
            .histogram-line {
                display: flex;
                align-items: baseline;
            }
            .histogram-label {
                width: 8ch;
                text-align: right;
                padding-right: 0.5em;
                flex-shrink: 0;
            }
            .histogram-separator {
                padding-right: 0.5em;
                flex-shrink: 0;
            }
            .histogram-bar {
                flex-grow: 1;
                white-space: nowrap;
                overflow: hidden;
                color: #4f46e5;
            }
            /* Style for summary lines */
            #result-summary div {
                margin-bottom: 0.3em;
            }
        </style>
    </head>
    <body
        class="bg-gray-100 text-gray-800 min-h-screen flex items-center justify-center p-4"
    >
        <div class="bg-white p-4 rounded-lg shadow-md w-full max-w-4xl">
            <h1
                class="text-3xl font-bold mb-6 text-center tracking-wide text-gray-700"
            >
                Unsure Calculator
            </h1>

            <div class="mb-4">
                <label
                    for="expression"
                    class="block text-sm font-medium text-gray-600 mb-1"
                    >Enter Expression:</label
                >
                <input
                    type="text"
                    id="expression"
                    placeholder="e.g., 100~200 * (5 ~ 7 + 1)"
                    class="block w-full px-4 py-3 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-lg leading-relaxed tracking-wider"
                />
            </div>

            <button
                id="calculateBtn"
                class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-4 rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition duration-150 ease-in-out text-lg tracking-wider"
            >
                Calculate
            </button>

            <div class="mt-6">
                <label class="block text-sm font-medium text-gray-600 mb-1"
                    >Result:</label
                >
                <div
                    id="result-container"
                    class="bg-gray-50 p-4 rounded-md text-sm leading-relaxed tracking-wider border border-gray-200 min-h-[4em] overflow-x-auto"
                >
                    <div id="result-summary"></div>
                    <div id="result-histogram"></div>
                </div>
            </div>
            <p class="text-xs text-gray-500 mt-4 text-center">
                Use '~' for ranges. Displays Exact & Simulated results.
            </p>
        </div>

        <script>
            const expressionInput = document.getElementById("expression");
            const calculateBtn = document.getElementById("calculateBtn");
            const resultSummaryDisplay =
                document.getElementById("result-summary");
            const resultHistogramDisplay =
                document.getElementById("result-histogram");
            const resultContainer = document.getElementById("result-container");

            const NUM_SAMPLES = 10000;
            const HISTOGRAM_BINS = 20;
            const HISTOGRAM_MAX_WIDTH = 40;
            const BAR_CHAR = "█";

            const params = new URLSearchParams(window.location.search);
            const expr = decodeURIComponent(params.get('expr'));
            if (expr !== "null") {
                expressionInput.value = expr;
            }

            // --- Gaussian Random Number Generator (Box-Muller Transform) ---
            let spareRandom = null;
            function gaussianRandom(mean, stdDev) {
                let u, v, s;
                if (spareRandom !== null) {
                    const temp = spareRandom;
                    spareRandom = null;
                    return mean + stdDev * temp;
                }
                do {
                    u = Math.random() * 2 - 1;
                    v = Math.random() * 2 - 1;
                    s = u * u + v * v;
                } while (s >= 1 || s === 0);
                const mul = Math.sqrt((-2.0 * Math.log(s)) / s);
                spareRandom = v * mul;
                return mean + stdDev * (u * mul);
            }

            function generateSamples(mean, stdDev) {
                if (stdDev === 0) {
                    // Optimization: if range is zero, all samples are the mean
                    return Array(NUM_SAMPLES).fill(mean);
                }
                const samples = [];
                for (let i = 0; i < NUM_SAMPLES; i++) {
                    samples.push(gaussianRandom(mean, stdDev));
                }
                return samples;
            }

            // --- Tokenizer (Unchanged) ---
            function tokenize(s) {
                const tokens = [];
                const NUMBER_REGEX = /^[0-9]+(\.[0-9]+)?/;
                const OPERATOR_REGEX = /^[+\-*/~()]/;
                const WHITESPACE_REGEX = /^\s+/;
                let remaining = s.trim();
                const originalString = s;
                while (remaining.length > 0) {
                    let match;
                    match = remaining.match(WHITESPACE_REGEX);
                    if (match) {
                        remaining = remaining.substring(match[0].length);
                        continue;
                    }
                    match = remaining.match(NUMBER_REGEX);
                    if (match) {
                        tokens.push(parseFloat(match[0]));
                        remaining = remaining.substring(match[0].length);
                        continue;
                    }
                    match = remaining.match(OPERATOR_REGEX);
                    if (match) {
                        tokens.push(match[0]);
                        remaining = remaining.substring(match[0].length);
                        continue;
                    }
                    throw new Error(
                        `Syntax Error: Cannot parse near '${remaining.substring(0, 10)}...' in expression '${originalString}'`,
                    );
                }
                return tokens;
            }

            function shuntingYard(tokens) {
                const outputQueue = [];
                const operatorStack = [];
                const precedence = { "+": 1, "-": 1, "*": 2, "/": 2, "~": 3 };
                const associativity = {
                    "+": "L",
                    "-": "L",
                    "*": "L",
                    "/": "L",
                    "~": "R",
                };
                for (const token of tokens) {
                    if (typeof token === "number") {
                        outputQueue.push(token);
                    } else if (token === "(") {
                        operatorStack.push(token);
                    } else if (token === ")") {
                        while (
                            operatorStack.length > 0 &&
                            operatorStack[operatorStack.length - 1] !== "("
                        ) {
                            outputQueue.push(operatorStack.pop());
                        }
                        if (operatorStack.length === 0)
                            throw new Error(
                                "Mismatched parentheses: Found ')' without matching '('",
                            );
                        operatorStack.pop();
                    } else if (precedence[token]) {
                        const op1 = token;
                        while (
                            operatorStack.length > 0 &&
                            operatorStack[operatorStack.length - 1] !== "(" &&
                            (precedence[
                                operatorStack[operatorStack.length - 1]
                            ] > precedence[op1] ||
                                (precedence[
                                    operatorStack[operatorStack.length - 1]
                                ] === precedence[op1] &&
                                    associativity[op1] === "L"))
                        ) {
                            outputQueue.push(operatorStack.pop());
                        }
                        operatorStack.push(op1);
                    } else {
                        throw new Error(`Unknown token: ${token}`);
                    }
                }
                while (operatorStack.length > 0) {
                    const op = operatorStack.pop();
                    if (op === "(")
                        throw new Error(
                            "Mismatched parentheses: Found '(' without matching ')'",
                        );
                    outputQueue.push(op);
                }
                return outputQueue;
            }

            function evalRpn(rpnQueue) {
                const stack = [];

                const createNumberValue = (num) => ({
                    mean: num,
                    min: num,
                    max: num,
                    samples: null,
                });

                const operateSamples = (samplesA, samplesB, operation) => {
                    if (!samplesA && !samplesB) return null; // Both numbers

                    const N = NUM_SAMPLES;
                    const resultSamples = Array(N);
                    const aIsArray = Array.isArray(samplesA);
                    const bIsArray = Array.isArray(samplesB);

                    for (let i = 0; i < N; i++) {
                        const a = aIsArray ? samplesA[i] : samplesA;
                        const b = bIsArray ? samplesB[i] : samplesB;

                        switch (operation) {
                            case "+":
                                resultSamples[i] = a + b;
                                break;
                            case "-":
                                resultSamples[i] = a - b;
                                break;
                            case "*":
                                resultSamples[i] = a * b;
                                break;
                            case "/":
                                resultSamples[i] = b === 0 ? NaN : a / b;
                                break;
                            default:
                                throw new Error(
                                    `Unknown sample operation: ${operation}`,
                                );
                        }
                    }
                    return resultSamples;
                };

                for (const token of rpnQueue) {
                    if (typeof token === "number") {
                        stack.push(createNumberValue(token));
                    } else if (token === "~") {
                        if (stack.length < 2)
                            throw new Error("Not enough operands for '~'");
                        const uvB = stack.pop();
                        const uvA = stack.pop();

                        // '~' must operate on plain numbers
                        if (
                            uvA.samples !== null ||
                            uvB.samples !== null ||
                            typeof uvA.mean !== "number" ||
                            typeof uvB.mean !== "number"
                        ) {
                            throw new Error(
                                "Operands for '~' must be exact numbers (e.g., 100~200, not (5~10)~200)",
                            );
                        }
                        const a = uvA.mean;
                        const b = uvB.mean;

                        const mean = (a + b) / 2.0;
                        const stdDev = Math.abs(b - a) / 3.28970725; // Approx 5th-95th range match
                        const samples = generateSamples(mean, stdDev);

                        stack.push({
                            mean: mean,
                            min: Math.min(a, b),
                            max: Math.max(a, b),
                            samples: samples,
                        });
                    } else if ("+-*/".includes(token)) {
                        if (stack.length < 2)
                            throw new Error(
                                `Not enough operands for '${token}'`,
                            );
                        const uvB = stack.pop();
                        const uvA = stack.pop();

                        let newMean, newMin, newMax;

                        // --- Calculate New Mean ---
                        // Approximation for * and / assuming independence (matches Monte Carlo implicit assumption)
                        switch (token) {
                            case "+":
                                newMean = uvA.mean + uvB.mean;
                                break;
                            case "-":
                                newMean = uvA.mean - uvB.mean;
                                break;
                            case "*":
                                newMean = uvA.mean * uvB.mean;
                                break;
                            case "/":
                                newMean =
                                    uvB.mean === 0 ? NaN : uvA.mean / uvB.mean;
                                break; // Handle division by zero mean
                        }

                        // --- Calculate New Min/Max (Interval Arithmetic) ---
                        const aMin = uvA.min,
                            aMax = uvA.max;
                        const bMin = uvB.min,
                            bMax = uvB.max;

                        switch (token) {
                            case "+":
                                newMin = aMin + bMin;
                                newMax = aMax + bMax;
                                break;
                            case "-":
                                newMin = aMin - bMax;
                                newMax = aMax - bMin;
                                break;
                            case "*":
                                const prods = [
                                    aMin * bMin,
                                    aMin * bMax,
                                    aMax * bMin,
                                    aMax * bMax,
                                ];
                                newMin = Math.min(...prods);
                                newMax = Math.max(...prods);
                                break;
                            case "/":
                                if (bMin <= 0 && bMax >= 0) {
                                    // Range includes zero
                                    if (bMin === 0 && bMax === 0) {
                                        // Division by exactly zero
                                        newMin = NaN;
                                        newMax = NaN;
                                        newMean = NaN; // Or throw error maybe?
                                    } else {
                                        // Range spans zero, result spans infinity (unless numerator is exactly 0)
                                        if (aMin === 0 && aMax === 0) {
                                            newMin = 0;
                                            newMax = 0;
                                        } else {
                                            newMin = -Infinity;
                                            newMax = Infinity;
                                        }
                                    }
                                } else {
                                    // Divisor range does not include zero
                                    const quots = [
                                        aMin / bMin,
                                        aMin / bMax,
                                        aMax / bMin,
                                        aMax / bMax,
                                    ];
                                    newMin = Math.min(...quots);
                                    newMax = Math.max(...quots);
                                }
                                break;
                        }

                        // --- Calculate New Samples ---
                        // Pass means if samples are null
                        const samplesA = uvA.samples ?? uvA.mean;
                        const samplesB = uvB.samples ?? uvB.mean;
                        const newSamples = operateSamples(
                            samplesA,
                            samplesB,
                            token,
                        );

                        stack.push({
                            mean: newMean,
                            min: newMin,
                            max: newMax,
                            samples: newSamples,
                        });
                    } else {
                        throw new Error(
                            `Internal Error: Unknown RPN token: ${token}`,
                        );
                    }
                }

                if (stack.length === 0) return null;
                if (stack.length > 1)
                    throw new Error("Invalid expression: Operands left over");
                return stack[0]; // The final UncertainValue object
            }

            // --- Quantile Calculation (Unchanged) ---
            function getQuantiles(samples) {
                if (!Array.isArray(samples) || samples.length === 0)
                    return { p05: NaN, p95: NaN };
                const validSamples = samples.filter(
                    (n) => !isNaN(n) && isFinite(n),
                );
                if (validSamples.length === 0) return { p05: NaN, p95: NaN };
                validSamples.sort((a, b) => a - b);
                const len = validSamples.length;
                const p05Index = Math.max(0, Math.floor(0.05 * len) - 1);
                const p95Index = Math.min(len - 1, Math.ceil(0.95 * len) - 1);
                return {
                    p05: validSamples[p05Index],
                    p95: validSamples[p95Index],
                };
            }

            // --- Format Number (Updated for better precision control) ---
            function formatNumber(num, padWidth = 0) {
                let str;
                const absNum = Math.abs(num);

                if (isNaN(num)) str = "NaN";
                else if (!isFinite(num))
                    str = num > 0 ? "Infinity" : "-Infinity";
                else if (absNum === 0) str = "0";
                else if (absNum < 1e-6 || absNum >= 1e9)
                    str = num.toExponential(4); // Exponential for very small/large
                else {
                    // Adaptive precision based on magnitude
                    let decimals;
                    if (absNum >= 1000) decimals = 1;
                    else if (absNum >= 100) decimals = 2;
                    else if (absNum >= 10) decimals = 3;
                    else if (absNum >= 1) decimals = 4;
                    else if (absNum >= 0.01) decimals = 5;
                    else decimals = 6; // More precision for smaller numbers

                    str = num.toFixed(decimals);
                    // Minimal cleanup
                    str = str.replace(/(\.[0-9]*?)0+$/, "$1"); // Remove trailing zeros
                    str = str.replace(/\.$/, ""); // Remove trailing decimal point
                }
                return padWidth > 0 ? str.padStart(padWidth) : str;
            }

            // --- Calculate Sample Mean (Unchanged) ---
            function calculateSampleMean(samples) {
                if (!Array.isArray(samples) || samples.length === 0) return NaN;
                const validSamples = samples.filter(
                    (n) => !isNaN(n) && isFinite(n),
                );
                if (validSamples.length === 0) return NaN;
                const sum = validSamples.reduce((acc, val) => acc + val, 0);
                return sum / validSamples.length;
            }

            // --- Generate Text Histogram (Unchanged) ---
            function generateTextHistogram(samples) {
                const numBins = HISTOGRAM_BINS;
                const maxBarWidth = HISTOGRAM_MAX_WIDTH;
                const output = [];
                if (!Array.isArray(samples) || samples.length === 0)
                    return ["Histogram data not available."];

                const validSamples = samples.filter(
                    (n) => !isNaN(n) && isFinite(n),
                );
                if (validSamples.length === 0)
                    return [
                        "Cannot generate histogram (no valid numeric samples).",
                    ];

                const minVal = Math.min(...validSamples);
                const maxVal = Math.max(...validSamples);
                const sampleMean = calculateSampleMean(validSamples);

                if (minVal === maxVal) {
                    const label = formatNumber(minVal, 7);
                    output.push(
                        `<div class="histogram-line"><span class="histogram-label">${label}</span><span class="histogram-separator">|</span><span class="histogram-bar">${BAR_CHAR.repeat(maxBarWidth)} (All samples)</span></div>`,
                    );
                    return output;
                }

                const binSize = (maxVal - minVal) / numBins;
                const binCounts = Array(numBins).fill(0);
                for (const sample of validSamples) {
                    let binIndex =
                        binSize === 0
                            ? 0
                            : Math.floor((sample - minVal) / binSize);
                    if (binIndex >= numBins) binIndex = numBins - 1;
                    if (binIndex < 0) binIndex = 0;
                    binCounts[binIndex]++;
                }

                const maxCount = Math.max(...binCounts);
                if (maxCount === 0)
                    return ["Cannot generate histogram (max count is zero)."];

                let peakBinIndex = binCounts.indexOf(maxCount);

                for (let i = numBins - 1; i >= 0; i--) {
                    const binStart = minVal + i * binSize;
                    const count = binCounts[i];
                    const barWidth =
                        maxCount === 0
                            ? 0
                            : Math.round((count / maxCount) * maxBarWidth);
                    const bar = BAR_CHAR.repeat(barWidth);
                    const label = formatNumber(binStart, 7);

                    let line = `<div class="histogram-line"><span class="histogram-label">${label}</span><span class="histogram-separator">|</span><span class="histogram-bar">${bar}`;
                    // Find which bin the sample mean falls into
                    let meanBinIndex =
                        binSize === 0
                            ? 0
                            : Math.floor((sampleMean - minVal) / binSize);
                    if (meanBinIndex >= numBins) meanBinIndex = numBins - 1;
                    if (meanBinIndex < 0) meanBinIndex = 0;
                    if (i === meanBinIndex) {
                        // Mark the bin containing the sample mean
                        line += ` (Sample Mean ≈${formatNumber(sampleMean)})`;
                    }
                    line += `</span></div>`;
                    output.push(line);
                }
                return output;
            }

            // --- Main Calculation Logic (Updated Output) ---
            function calculate() {
                const expression = expressionInput.value;
                resultSummaryDisplay.innerHTML = "<div>Calculating...</div>"; // Use innerHTML for multiple lines
                resultHistogramDisplay.innerHTML = "";
                resultContainer.classList.remove("border-red-600");
                resultSummaryDisplay.classList.remove("text-red-600");

                if (expression) {
                    // set query params
                    const params = new URLSearchParams();
                    params.set('expr', encodeURIComponent(expression));
                    window.history.pushState(null, '', `?${params.toString()}`);
                }

                setTimeout(() => {
                    try {
                        if (!expression.trim()) {
                            resultSummaryDisplay.innerHTML = "";
                            return;
                        }
                        const tokens = tokenize(expression);
                        const rpn = shuntingYard(tokens);
                        const result = evalRpn(rpn); // result is an UncertainValue object

                        if (!result) {
                            resultSummaryDisplay.innerHTML = "";
                            return;
                        }

                        let summaryHtml = "";
                        let hasError = false;

                        // Display Exact Results
                        if (
                            isNaN(result.mean) ||
                            isNaN(result.min) ||
                            isNaN(result.max)
                        ) {
                            summaryHtml += `<div><span class="text-red-600">Exact Result Contains NaN</span></div>`;
                            hasError = true;
                        } else {
                            summaryHtml += `<div>Exact Average: ${formatNumber(result.mean)}</div>`;
                            summaryHtml += `<div>Exact Range : ${formatNumber(result.min)} - ${formatNumber(result.max)}</div>`;
                        }

                        // Display Simulation Results (if applicable)
                        if (result.samples) {
                            const quantiles = getQuantiles(result.samples);
                            if (isNaN(quantiles.p05) || isNaN(quantiles.p95)) {
                                summaryHtml += `<div><span class="text-red-600">Simulated Result Contains NaN/Infinity</span></div>`;
                                hasError = true;
                            } else {
                                summaryHtml += `<div class="mt-2">Simulated Range (5%-95%): ${formatNumber(quantiles.p05)} ~ ${formatNumber(quantiles.p95)}</div>`;
                            }
                            // Generate and display histogram
                            const histogramLines = generateTextHistogram(
                                result.samples,
                            );
                            resultHistogramDisplay.innerHTML =
                                histogramLines.join("");
                        } else {
                            resultHistogramDisplay.innerHTML = ""; // Clear histogram if no samples
                            summaryHtml += `<div class="mt-2">(Result is an exact number, no simulation needed)</div>`;
                        }

                        resultSummaryDisplay.innerHTML = summaryHtml;
                        if (hasError) {
                            resultContainer.classList.add("border-red-600");
                        }
                    } catch (error) {
                        console.error("Calculation Error:", error);
                        resultSummaryDisplay.innerHTML = `<div><span class="text-red-600">Error: ${error.message}</span></div>`;
                        resultContainer.classList.add("border-red-600");
                        resultHistogramDisplay.innerHTML = ""; // Clear histogram on error
                    }
                }, 10);
            }

            // --- Event Listeners ---
            calculateBtn.addEventListener("click", calculate);
            expressionInput.addEventListener("keypress", (event) => {
                if (event.key === "Enter") calculate();
            });

            // --- Initial example calculation ---
            if (!expressionInput.value) {
                expressionInput.value = "100~200 * 2~4 / 2~4";
            }
            calculate();
        </script>
    </body>
</html>